// Generated by CoffeeScript 1.9.3
(function() {
  var Stream, fs, getIssueFile, get_issue, handle, handle_one, http, log, path, poolling, process_dirs, process_queue, process_test, request, requestSync, setAsDone, setAsProblem, utils,
    indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  http = require('http');

  fs = require('fs');

  path = require('path');

  utils = require('../utils/utils');

  request = require('request');

  log = require('winston-color');

  log.level = process.env.LOG_LEVEL;

  log.debug("Importing polling queue module");

  requestSync = require('sync-request');

  Stream = require('stream').Transform;

  get_issue = function(id) {
    var dest, ik, iv, jk, jsondata, jv, k, ref, ref1, ref2, v;
    dest = path.join(global.app_root, global.app_config.data_dir, "catalog", "catalog.json");
    jsondata = JSON.parse(fs.readFileSync(dest, 'utf8'));
    ref = jsondata.categories;
    for (k in ref) {
      v = ref[k];
      ref1 = v.journals;
      for (jk in ref1) {
        jv = ref1[jk];
        ref2 = jv.issues;
        for (ik in ref2) {
          iv = ref2[ik];
          if (iv.id = id) {
            return iv;
          }
        }
      }
    }
    return null;
  };

  process_dirs = function(file) {
    var arr, article_dir, issue, issue_covers_dir, issue_dir, issue_id, issue_page_dir, jar, journal_dir, journal_id;
    arr = file.split('.');
    jar = arr[0].split('-');
    journal_id = jar[0];
    issue_id = jar[1];
    issue = get_issue(issue_id);
    if (!issue) {
      return false;
    }
    setAsDone(issue_id);
    journal_dir = path.join(global.app_root, global.app_config.data_dir, 'journals', "" + journal_id);
    if (!fs.existsSync(journal_dir)) {
      log.verbose("Creating " + journal_dir);
      fs.mkdirSync(journal_dir);
    }
    issue_dir = path.join(journal_dir, "" + issue_id);
    if (!fs.existsSync(issue_dir)) {
      log.verbose("Creating " + issue_dir);
      fs.mkdirSync(issue_dir);
    }
    issue_page_dir = path.join(issue_dir, "pages");
    if (!fs.existsSync(issue_page_dir)) {
      log.verbose("Creating " + issue_page_dir);
      fs.mkdirSync(issue_page_dir);
    }
    issue_covers_dir = path.join(issue_dir, "thumbnails");
    if (!fs.existsSync(issue_covers_dir)) {
      log.verbose("Creating " + issue_covers_dir);
      fs.mkdirSync(issue_covers_dir);
    }
    if (issue.has_articles) {
      article_dir = path.join(global.app_root, global.app_config.data_dir, 'articles', "" + journal_id);
      if (!fs.existsSync(article_dir)) {
        log.verbose("Creating " + article_dir);
        fs.mkdirSync(article_dir);
      }
      article_dir = path.join(article_dir, "" + issue_id);
      if (!fs.existsSync(article_dir)) {
        log.verbose("Creating " + article_dir);
        fs.mkdirSync(article_dir);
      }
    }
    return true;
  };

  process_test = function(lst) {
    if (lst.length === 0) {
      return;
    }
    console.log(lst);
    lst.splice(0, 1);
    return process_test(lst);
  };

  setAsProblem = function(item) {
    var done_path, jsondata;
    done_path = path.join(global.app_root, global.app_config.data_dir, 'problem_journal.json');
    jsondata = fs.readFileSync(done_path, 'utf-8');
    jsondata = JSON.parse(jsondata);
    jsondata.push(item);
    return fs.writeFileSync(done_path, JSON.stringify(jsondata));
  };

  setAsDone = function(issue_id) {
    var done_path, jsondata;
    done_path = path.join(global.app_root, global.app_config.data_dir, 'done.json');
    jsondata = fs.readFileSync(done_path, 'utf-8');
    jsondata = JSON.parse(jsondata);
    if (indexOf.call(jsondata, issue_id) < 0) {
      jsondata.push(parseInt(issue_id));
      return fs.writeFileSync(done_path, JSON.stringify(jsondata));
    }
  };

  process_queue = function(lst, clb) {
    var cont, dest, info, ref, ref1, ref2, req, url;
    if (lst.length === 0) {
      clb();
      return;
    }
    url = lst[0].uri;
    log.debug("TASK QUEUE:  process " + lst[0].type);
    if ((ref = lst[0].type) === 'article-image' || ref === 'cover' || ref === 'page' || ref === 'page-thumb') {
      log.debug("TASK QUEUE:  request " + lst[0].type + " " + url);
      if (url === 'http://pressa.ru/static/article/img/art_cover.png') {
        dest = path.join(global.app_root, 'public', 'images', 'art_cover.png');
        dest = dest.replace('.jpg', '.png');
        fs.writeFileSync(lst[0].path, fs.readFileSync(dest));
        lst.splice(0, 1);
        return process_queue(lst, clb);
      } else {
        req = http.get(url, function(res) {
          var out;
          out = new Stream();
          res.on('data', function(chunk) {
            return out.push(chunk);
          });
          return res.on('end', function() {
            console.log('end request');
            fs.writeFileSync(lst[0].path, out.read());
            lst.splice(0, 1);
            return process_queue(lst, clb);
          });
        });
        req.on('socket', function(socket) {
          socket.setTimeout(15000);
          return socket.on('timeout', function() {
            req.abort();
            lst.splice(0, 1);
            return process_queue(lst, clb);
          });
        });
        return req.on('error', function(err) {
          if (err.code === 'ECONNRESET') {
            log.error('Timeout');
            return setAsProblem(lst[0]);
          }
        });
      }
    } else if ((ref1 = lst[0].type) === 'article-json' || ref1 === 'pages-json' || ref1 === 'page') {
      log.debug("TASK QUEUE:  request json " + url);
      req = http.get(url, function(res) {
        var out;
        out = '';
        res.on('data', function(chunk) {
          return out = out + chunk;
        });
        return res.on('end', function() {
          fs.writeFileSync(lst[0].path, out);
          lst.splice(0, 1);
          return process_queue(lst, clb);
        });
      });
      req.on('socket', function(socket) {
        socket.setTimeout(15000);
        return socket.on('timeout', function() {
          req.abort();
          lst.splice(0, 1);
          return process_queue(lst, clb);
        });
      });
      return req.on('error', function(err) {
        if (err.code === 'ECONNRESET') {
          return log.error('Timeout!!!');
        }
      });
    } else if ((ref2 = lst[0].type) === 'info') {
      info = lst[0].content;
      dest = path.join(global.app_root, global.app_config.data_dir, 'journals', "" + info.journal_id, "" + info.id, "info.json");
      if (!fs.existsSync(dest)) {
        cont = fs.writeFileSync(dest, JSON.stringify(info));
      }
      lst.splice(0, 1);
      return process_queue(lst, clb);
    } else {
      lst.splice(0, 1);
      return process_queue(lst, clb);
    }
  };

  getIssueFile = function() {
    var cont, dest, destf, files;
    dest = path.join(global.app_root, global.app_config.data_dir, "queue");
    files = [];
    fs.readdirSync(dest).forEach(function(file) {
      return files.push(file);
    });
    if (files.length > 0) {
      destf = path.join(dest, files[0]);
      cont = JSON.parse(fs.readFileSync(destf, 'utf8'));
      if (!process_dirs(files[0])) {
        return [];
      }
      fs.unlinkSync(destf);
      return cont;
    } else {
      return false;
    }
    return destf;
  };

  handle = function(clb) {
    var jsondata;
    console.log('Go');
    jsondata = getIssueFile();
    if (jsondata) {
      return process_queue(jsondata, function() {
        return handle(clb);
      });
    } else {
      return clb();
    }
  };

  handle_one = function(clb) {
    var jsondata;
    log.debug('Start');
    jsondata = getIssueFile();
    if (jsondata) {
      log.debug("GETING ONE ITEM: " + jsondata.length + " items");
      process_queue(jsondata, function() {});
      return clb();
    } else {
      log.debug('No items to process!');
      return clb();
    }
  };

  poolling = {
    handle: handle,
    handle_one: handle_one
  };

  module.exports = poolling;

}).call(this);
