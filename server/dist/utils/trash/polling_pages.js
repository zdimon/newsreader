// Generated by CoffeeScript 1.9.3
(function() {
  var crop_issues, fs, http, issue, log, path, poolling, process_big_pages, process_catalog, process_issue, process_pages, read_catalog, request, requestSync, save_page_json, utils;

  http = require('http');

  fs = require('fs');

  path = require('path');

  utils = require('../utils/utils');

  request = require('request');

  issue = require('./polling_issues');

  log = require('winston-color');

  log.level = process.env.LOG_LEVEL;

  log.debug("Importing polling pages module");

  requestSync = require('sync-request');

  read_catalog = function(path, clb) {
    return fs.readFile(path, 'utf8', function(err, data) {
      if (err) {
        return clb(null, "" + err);
      } else {
        return clb(JSON.parse(data));
      }
    });
  };

  process_big_pages = function(pages) {
    var count, im_url, image_path, issue_path, pk, pv, ref, res, results;
    count = 0;
    issue_path = path.join(global.app_root, global.app_config.data_dir, "journals/" + pages.journal_id + "/" + pages.issue_id + "/thumbnail_done.dat");
    ref = pages.pages;
    results = [];
    for (pk in ref) {
      pv = ref[pk];
      count = count + 1;
      im_url = "http://" + global.remote_host + "/zd/page/" + pv.id + "/blabla.json";
      log.info(im_url);
      log.verbose("PAGES: saving... " + pages.journal_id + "-" + pages.issue_id + "-" + pv.number + "  fucking big page!");
      image_path = path.join(global.app_root, global.app_config.data_dir, "journals/" + pages.journal_id + "/" + pages.issue_id + "/pages/" + pv.number + ".jpg");
      res = requestSync('GET', im_url);
      fs.writeFileSync(image_path, res.getBody());
      if (count === parseInt(pages.check_sum)) {
        results.push(fs.writeFileSync(issue_path, ''));
      } else {
        results.push(void 0);
      }
    }
    return results;
  };

  process_pages = function(pages) {
    var im_url, image_path, pk, pv, ref, res, results;
    ref = pages.pages;
    results = [];
    for (pk in ref) {
      pv = ref[pk];
      im_url = "http://" + global.remote_host + pv.cover;
      log.verbose("PAGES: saving... " + pages.journal_id + "-" + pages.issue_id + "-" + pv.number + " small fucking page");
      image_path = path.join(global.app_root, global.app_config.data_dir, "journals/" + pages.journal_id + "/" + pages.issue_id + "/thumbnails/" + pv.number + ".jpg");
      res = requestSync('GET', im_url);
      results.push(fs.writeFileSync(image_path, res.getBody()));
    }
    return results;
  };

  process_issue = function(issue) {
    var issue_done_path, res, url;
    url = "http://" + global.remote_host + "/zd/" + issue.id + ".json";
    issue_done_path = path.join(global.app_root, global.app_config.data_dir, "journals/" + issue.journal_id + "/" + issue.id + "/thumbnail_done.dat");
    if (!fs.existsSync(issue_done_path)) {
      res = requestSync('GET', url);
      process_pages(JSON.parse(res.getBody()));
      return process_big_pages(JSON.parse(res.getBody()));
    }
  };

  save_page_json = function(issue) {
    var issue_pages_path, res, url;
    url = "http://" + global.remote_host + "/zd/" + issue.id + ".json";
    res = requestSync('GET', url);
    issue_pages_path = path.join(global.app_root, global.app_config.data_dir, "journals/" + issue.journal_id + "/" + issue.id + "/pages.json");
    fs.writeFileSync(issue_pages_path, res.getBody(), 'utf-8');
    return log.info("PAGES: saving JSON  " + issue_pages_path);
  };

  process_catalog = function(clb) {
    var catalog_path;
    log.debug("Process catalog");
    catalog_path = path.join(global.app_root, global.app_config.data_dir, "catalog/catalog.json");
    return read_catalog(catalog_path, function(data, err) {
      var ik, iv, jk, jv, k, ref, ref1, ref2, v;
      if (err) {
        return clb("" + err);
      } else {
        ref = data.categories;
        for (k in ref) {
          v = ref[k];
          ref1 = v.journals;
          for (jk in ref1) {
            jv = ref1[jk];
            ref2 = jv.issues;
            for (ik in ref2) {
              iv = ref2[ik];
              process_issue(iv);
            }
          }
        }
        return clb();
      }
    });
  };

  crop_issues = function() {
    return log.debug("PAGE: cropping");
  };

  poolling = {
    process_catalog: process_catalog,
    process_issue: process_issue,
    save_page_json: save_page_json,
    crop_issues: crop_issues
  };

  module.exports = poolling;

}).call(this);
