// Generated by CoffeeScript 1.9.3
(function() {
  var create_dirs, create_list_of_issues, crop_image, crop_images, download_images, easyimg, fs, get_and_save_article, get_articles_from_server, grab_articles, http, inspector, log, make_http_request, manage_with_dirs, path, poolling, proc_save_json_to_disk, process_queue_articles, read_catalog, request, requestSync, utils, write_problems,
    indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  http = require('http');

  fs = require('fs');

  path = require('path');

  utils = require('../utils/utils');

  request = require('request');

  log = require('winston-color');

  log.level = process.env.LOG_LEVEL;

  log.debug("Importing polling articles module");

  requestSync = require('sync-request');

  easyimg = require('easyimage');

  inspector = require('./polling_inspector');

  read_catalog = function() {
    var cont, dest;
    try {
      dest = path.join(global.app_root, global.app_config.data_dir, "catalog/catalog.json");
      cont = JSON.parse(fs.readFileSync(dest, 'utf8'));
      return cont;
    } catch (_error) {
      return {
        code: 1,
        message: 'file does not exist!'
      };
    }
  };

  download_images = function(jsdata) {
    var i, image_path, image_pathb, j, len, ref, res, results;
    try {
      jsdata = JSON.parse(jsdata);
    } catch (_error) {
      log.error("Wrong json");
      console.log(jsdata);
      return;
    }
    ref = jsdata.articles;
    results = [];
    for (j = 0, len = ref.length; j < len; j++) {
      i = ref[j];
      image_path = path.join(global.app_root, global.app_config.data_dir, "articles", "" + i.journal_id, "" + i.issue_id, i.id + ".png");
      res = requestSync('GET', i.small_image);
      fs.writeFileSync(image_path, res.getBody());
      image_pathb = path.join(global.app_root, global.app_config.data_dir, "articles", "" + i.journal_id, "" + i.issue_id, i.id + "_big.png");
      res = requestSync('GET', i.image);
      fs.writeFileSync(image_pathb, res.getBody());
      results.push(log.debug("ARTICLE: Image saved " + i.id));
    }
    return results;
  };

  get_and_save_article = function(url, dest, callback) {
    var req;
    log.debug("ARTICLE: Start loading from " + url);
    req = http.get(url, function(res) {
      var out;
      out = '';
      res.on('data', function(chunk) {
        return out = out + chunk;
      });
      return res.on('end', function() {
        var jsdata;
        jsdata = JSON.parse(out);
        return fs.writeFile(dest, out, function(err) {
          if (err) {
            log.error(err);
          }
          console.log("ARTICLE: End loading file " + dest + " has been saved!");
          return callback(jsdata);
        });
      });
    });
    req.on('socket', function(socket) {
      socket.setTimeout(30000);
      return socket.on('timeout', function() {
        return req.abort();
      });
    });
    return req.on('error', function(err) {
      if (err.code === 'ECONNRESET') {
        return log.error("ARTICLE: timeout " + url);
      }
    });
  };

  manage_with_dirs = function(issue) {
    var issue_dir, journal_dir;
    journal_dir = path.join(global.app_root, global.app_config.data_dir, "articles", "" + issue.journal_id);
    if (!fs.existsSync(journal_dir)) {
      fs.mkdirSync(journal_dir);
    }
    issue_dir = path.join(journal_dir, "" + issue.id);
    if (!fs.existsSync(issue_dir)) {
      return fs.mkdirSync(issue_dir);
    }
  };

  process_queue_articles = function(lst) {
    var cont, dest, dest_done, i, index, j, len, out, res, results, url;
    if (lst.length === 0) {
      return;
    }
    results = [];
    for (j = 0, len = lst.length; j < len; j++) {
      i = lst[j];
      index = lst.indexOf(i);
      if (index > -1) {
        dest_done = path.join(global.app_root, global.app_config.data_dir, "articles", i.journal_id + "/" + i.id + "/done.dat");
        if (!fs.existsSync(dest_done)) {
          manage_with_dirs(i);
          url = "http://pressa.ru/zd/txt/" + i.id + ".json";
          log.debug("ARTICLE: loading " + url);
          res = requestSync('GET', url);
          out = res.getBody('utf8');
          dest = path.join(global.app_root, global.app_config.data_dir, "articles", i.journal_id + "/" + i.id + "/articles.json");
          fs.writeFileSync(dest, out, 'utf-8');
          console.log("ARTICLE: file " + dest + " has been saved!");
          download_images(out);
          crop_image({
            journal_id: i.journal_id,
            id: i.id
          });
          try {
            cont = JSON.parse(fs.readFileSync(dest, 'utf8'));
            fs.writeFileSync(dest_done, "1");
          } catch (_error) {
            process_queue_articles(lst);
          }
        }
        lst.splice(index, 1);
        results.push(process_queue_articles(lst));
      } else {
        results.push(void 0);
      }
    }
    return results;
  };

  get_articles_from_server = function() {
    var cat, ik, iv, jk, jv, k, loaded, ref, ref1, ref2, ref3, url, v;
    log.debug("ARTICLES: Reading catalog");
    cat = read_catalog();
    loaded = [];
    ref = cat.categories;
    for (k in ref) {
      v = ref[k];
      ref1 = v.journals;
      for (jk in ref1) {
        jv = ref1[jk];
        ref2 = jv.issues;
        for (ik in ref2) {
          iv = ref2[ik];
          if (iv.has_articles) {
            if (ref3 = iv.id, indexOf.call(loaded, ref3) < 0) {
              url = "http://pressa.ru/zd/txt/" + iv.id + ".json";
              loaded.push(iv);
            }
          }
        }
      }
    }
    return process_queue_articles(loaded);

    /*
        dest = path.join issue_dir, "articles.json"
        if !fs.existsSync dest
            get_and_save_article url,dest, (jsdata)->
                download_images(jsdata)
     */
  };

  crop_images = function() {
    var cat, i, ik, iv, jk, jv, k, loaded, ref, ref1, ref2, results, v;
    log.verbose("ARTICLE: cropping images");
    cat = read_catalog();
    loaded = [];
    ref = cat.categories;
    for (k in ref) {
      v = ref[k];
      ref1 = v.journals;
      for (jk in ref1) {
        jv = ref1[jk];
        ref2 = jv.issues;
        for (ik in ref2) {
          iv = ref2[ik];
          if (iv.has_articles) {
            loaded.push(iv);
          }
        }
      }
    }
    results = [];
    for (i in loaded) {
      v = loaded[i];
      results.push(crop_image(v));
    }
    return results;
  };

  crop_image = function(jsondata) {
    var cont, i, opt, path_to_image, path_to_image_crop, path_to_json, ref, results, v;
    log.verbose("ARTICLE: cropping process " + jsondata.id);
    path_to_json = path.join(global.app_root, global.app_config.data_dir, "articles", jsondata.journal_id + "/" + jsondata.id + "/articles.json");
    log.debug(path_to_json);
    cont = JSON.parse(fs.readFileSync(path_to_json, 'utf8'));
    ref = cont.articles;
    results = [];
    for (i in ref) {
      v = ref[i];
      path_to_image = path.join(global.app_root, global.app_config.data_dir, "articles", jsondata.journal_id + "/" + jsondata.id + "/" + v.id + ".png");
      path_to_image_crop = path.join(global.app_root, global.app_config.data_dir, "articles", jsondata.journal_id + "/" + jsondata.id + "/" + v.id + ".png");
      opt = {
        src: path_to_image,
        dst: path_to_image_crop,
        x: 0,
        y: 0,
        cropwidth: 80,
        cropheight: 80
      };
      results.push(easyimg.crop(opt).then(function(file) {
        return log.debug("Image croped " + file.width + "x" + file.height);
      }, function(err) {
        return console.log(err);
      }));
    }
    return results;
  };

  write_problems = function(id, journal_id) {
    var cont, el, path_to_problems;
    path_to_problems = path.join(global.app_root, global.app_config.data_dir, "articles", "problems.json");
    if (!fs.existsSync(path_to_problems)) {
      fs.writeFileSync(path_to_problems, '[]', 'utf-8');
    }
    cont = JSON.parse(fs.readFileSync(path_to_problems, 'utf8'));
    el = {
      journal_id: journal_id,
      id: id
    };
    if (indexOf.call(cont, el) < 0) {
      cont.push(el);
      return fs.writeFileSync(path_to_problems, JSON.stringify(cont), 'utf-8');
    }
  };

  create_list_of_issues = function(clb) {
    var issues, path_to_catalog;
    log.debug("Creating list of issues....");
    issues = [];
    path_to_catalog = path.join(global.app_root, global.app_config.data_dir, "catalog/catalog.json");
    return fs.readFile(path_to_catalog, 'utf-8', function(err, data) {
      var cont, e, ik, iv, jk, jv, k, ref, ref1, ref2, ref3, v;
      if (err) {
        return clb(null, err);
      } else {
        try {
          cont = JSON.parse(data);
          ref = cont.categories;
          for (k in ref) {
            v = ref[k];
            ref1 = v.journals;
            for (jk in ref1) {
              jv = ref1[jk];
              ref2 = jv.issues;
              for (ik in ref2) {
                iv = ref2[ik];
                if (iv.has_articles) {
                  if (ref3 = iv.id, indexOf.call(issues, ref3) < 0) {
                    issues.push({
                      journal_id: iv.journal_id,
                      id: iv.id
                    });
                  }
                }
              }
            }
          }
          return clb(issues);
        } catch (_error) {
          e = _error;
          return clb(null, e);
        }
      }
    });
  };

  make_http_request = function(url, clb) {
    var req;
    log.debug("Making HTTP async request to " + url);
    req = http.get(url, function(res) {
      var out;
      out = '';
      res.on('data', function(chunk) {
        return out = out + chunk;
      });
      return res.on('end', function() {
        return clb(out);
      });
    });
    req.on('socket', function(socket) {
      socket.setTimeout(20000);
      return socket.on('timeout', function() {
        return req.abort();
      });
    });
    return req.on('error', function(err) {
      if (err.code === 'ECONNRESET') {
        log.error("ARTICLE: timeout " + url);
        return clb(null, "Timeout error");
      }
    });
  };

  create_dirs = function(journal_id, issue_id, clb) {
    var issue_dir, journal_dir;
    journal_dir = path.join(global.app_root, global.app_config.data_dir, "articles", "" + journal_id);
    if (!fs.existsSync(journal_dir)) {
      fs.mkdirSync(journal_dir);
    }
    issue_dir = path.join(journal_dir, "" + issue_id);
    if (!fs.existsSync(issue_dir)) {
      return fs.mkdirSync(issue_dir);
    }
  };

  proc_save_json_to_disk = function(lst, clb) {
    var proc_dwn_images, save_json_to_disk;
    log.debug("ARTICLES: saving json");
    proc_dwn_images = function(lst, clb) {
      var dwn_image;
      dwn_image = function(lst) {
        if (lst[0]) {
          log.debug(lst[0].url);
          return request(lst[0].url).pipe(fs.createWriteStream(lst[0].image_path)).on('close', function() {
            lst.splice(0, 1);
            return dwn_image(lst);
          }).on('error', function() {
            lst.splice(0, 1);
            return dwn_image(lst);
          });
        } else {
          return clb();
        }
      };
      return dwn_image(lst);
    };
    save_json_to_disk = function(lst) {
      var url;
      if (lst[0]) {
        if (inspector.is_done({
          object: "articles",
          id: lst[0].id
        })) {
          console.log(lst[0].id);
          lst.splice(0, 1);
          return save_json_to_disk(lst);
        } else {
          url = "http://pressa.ru/zd/txt/" + lst[0].id + ".json";
          return make_http_request(url, function(data, err) {
            var dest, jsdata;
            if (err) {
              log.error("TIMEOUT ERROR repeat request");
              return save_json_to_disk(lst);
            } else {
              try {
                jsdata = JSON.parse(data);
                dest = path.join(global.app_root, global.app_config.data_dir, "articles", lst[0].journal_id + "/" + lst[0].id + "/articles.json");
                create_dirs(lst[0].journal_id, lst[0].id);
                return fs.writeFile(dest, JSON.stringify(jsdata), 'utf-8', function(err) {
                  var i, image_path, images_big, images_small, j, l, len, len1, ref, ref1;
                  if (err) {
                    log.error(err);
                  }
                  images_small = [];
                  ref = jsdata.articles;
                  for (j = 0, len = ref.length; j < len; j++) {
                    i = ref[j];
                    image_path = path.join(global.app_root, global.app_config.data_dir, "articles", "" + i.journal_id, "" + i.issue_id, i.id + ".png");
                    images_small.push({
                      image_path: image_path,
                      url: i.square_image
                    });
                  }
                  images_big = [];
                  ref1 = jsdata.articles;
                  for (l = 0, len1 = ref1.length; l < len1; l++) {
                    i = ref1[l];
                    image_path = path.join(global.app_root, global.app_config.data_dir, "articles", "" + i.journal_id, "" + i.issue_id, i.id + "_big.png");
                    images_big.push({
                      image_path: image_path,
                      url: i.image
                    });
                  }
                  return proc_dwn_images(images_small, function() {
                    return proc_dwn_images(images_big, function() {
                      inspector.mark_as_done({
                        object: "article",
                        id: lst[0].id
                      });
                      lst.splice(0, 1);
                      return save_json_to_disk(lst);
                    });
                  });
                });
              } catch (_error) {
                log.error("JSON parse error, repeat request");
                return save_json_to_disk(lst);
              }
            }
          });
        }
      } else {
        console.log(lst);
        return clb(lst);
      }
    };
    return save_json_to_disk(lst);
  };

  grab_articles = function() {
    log.debug("Grabbing articles...");
    return create_list_of_issues(function(data, err) {
      var lst_for_images, lst_for_json;
      if (err) {
        return log.error("ARTICLE ERROR: " + err);
      } else {
        lst_for_json = data.slice();
        lst_for_images = data.slice();
        return proc_save_json_to_disk(lst_for_json, function() {
          return log.debug("Finished");
        });
      }
    });
  };

  poolling = {
    get_articles_from_server: get_articles_from_server,
    get_and_save_article: get_and_save_article,
    process_queue_articles: process_queue_articles,
    crop_images: crop_images,
    grab_articles: grab_articles
  };

  module.exports = poolling;

}).call(this);
